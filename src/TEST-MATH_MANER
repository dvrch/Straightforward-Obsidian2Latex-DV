import re
from pathlib import Path
import os
import yaml

# === EN-T√äTE : Table de correspondance ===
alias_map = {
    'a': 'cle',
    'b': 'motif',
    'c': 'chemins',
    'd': 'racine',
    'e': 'rmt',
    'f': 'motifs',
    'g': 'cle_pattern_paths',
    'h': 'fl',
}

class AliasNamespace:
    def __init__(self, alias_map, context):
        self.alias_map = alias_map
        self.context = context
    def __getitem__(self, key):
        varname = self.alias_map.get(key, key)
        return self.context[varname]
    def __setitem__(self, key, value):
        varname = self.alias_map.get(key, key)
        self.context[varname] = value

# --- D√âFINITION DES VARIABLES ---

cle = "cl√©_exemple"
motif = "motif_exemple"
chemins = ["chemin1", "chemin2"]
racine = "/chemin/vers/racine"
rmt = lambda racine, motif: ["chemin_trouv√©"]
motifs = {"cl√©_exemple": "motif_exemple"}
cle_pattern_paths = {"cl√©_exemple": "cl√©_exemple chemin_trouv√©"}
fl = """ 
"""
# --------------------


vari[f] = {
    vari[a]: (yaml.safe_load(open("fl.md", encoding="utf-8")) 
        if Path("fl.md").is_file() else {}).get(vari[a]) 
            or val 
    for vari[a], val in yaml.safe_load(fl).items()
}

# --- CR√âATION DU NAMESPACE D'ALIAS ---
vari = AliasNamespace(alias_map, globals())

# --- UTILISATION DES ALIAS DANS LES COMPR√âHENSIONS ---
# Tu peux utiliser variables['e'] (ou variables['rmt']) partout, m√™me dans les compr√©hensions
vari[d] =  Path("/chemin/absolu/vers/racine")
vari[e] =  lambda vari[d], vari[b], dossier1st='d': [
    str(item)
    for dossier, sous_dossiers, fichiers in os.walk(Path(vari[d]))
    for item in (
        [*(Path(dossier)/d for d in sous_dossiers), *(Path(dossier)/f for f in fichiers)]
        if dossier1st == 'd'
        else [*(Path(dossier)/f for f in fichiers), *(Path(dossier)/d for d in sous_dossiers)]
    )
    if re.search( vari[b], item.name, re.I)
]

vari[h] = """ 
base_path : "bbb"
lauch_sh : r"*.sh"
launch_py : 
latex_file : writing.tex
pdf_file : writing.pdf
path_vault:   example_vault  
path_writing:   ‚úçWriting  
path_templates:   üë®‚ÄçüíªAutomations  
path_table_block_template:   table_block.md  
path_equation_block_template:   equation_block_single.md  
path_equation_blocks:   equation blocks  
path_table_blocks:   table blocks  
path_list_note_paths:   DO_NOT_DELETE__note_paths.txt  
path_BIBTEX:   BIBTEX  
"""
cle_pattern_paths = g = {
    a: f'{a} "{c[0]}"' if (c := vari['e'](vari['d'], b)) else f'{a} "affich non trouv√©"'
    for a, b in vari['f'].items()
}

print(vari['g'])  # ou print(g), c'est pareil !

# Exemple d'acc√®s √† une variable interm√©diaire :
for a, b in vari['f'].items():
    c = vari['e'](vari['d'], b)
    print(f"{a}: {c}")


# import re
# from pathlib import Path
# import os

# import yaml


# import re
# from pathlib import Path
# import os
# import yaml

# # Correspondance des variables math√©matiques
# # a : cl√© (cle)
# # b : motif (motif)
# # c : chemins (chemins)
# # d : racine (racine)
# # e : fonction de recherche (rmt)
# # f : dictionnaire des motifs (motifs)
# # g : r√©sultat final (cle_pattern_paths)

# # Fonction de recherche (e)
# e = lambda d, b, dossier1st='d': [
#     str(item)
#     for dossier, sous_dossiers, fichiers in os.walk(Path(d))
#     for item in (
#         [*(Path(dossier)/d for d in sous_dossiers), *(Path(dossier)/f for f in fichiers)]
#         if dossier1st == 'd'
#         else [*(Path(dossier)/f for f in fichiers), *(Path(dossier)/d for d in sous_dossiers)]
#     )
#     if re.search(b, item.name, re.I)
# ]

# # Racine fixe pour √©viter l'erreur __file__
# d = Path("/chemin/absolu/vers/racine")

# # Valeurs par d√©faut YAML (fl)
# fl = """ 
# base_path : "bbb"
# lauch_sh : r"*.sh"
# launch_py : 
# latex_file : writing.tex
# pdf_file : writing.pdf
# path_vault:   example_vault  
# path_writing:   ‚úçWriting  
# path_templates:   üë®‚ÄçüíªAutomations  
# path_table_block_template:   table_block.md  
# path_equation_block_template:   equation_block_single.md  
# path_equation_blocks:   equation blocks  
# path_table_blocks:   table blocks  
# path_list_note_paths:   DO_NOT_DELETE__note_paths.txt  
# path_BIBTEX:   BIBTEX  
# """

# # Chargement des motifs (f)
# f = {
#     a: (yaml.safe_load(open("fl.md", encoding="utf-8")) 
#         if Path("fl.md").is_file() else {}).get(a) 
#             or val 
#     for a, val in yaml.safe_load(fl).items()
# }

# # Construction du dictionnaire final (g)
# g = {
#     a: f'{a} "{c[0]}"' if (c := e(d, b)) else f'{a} "affich non trouv√©"'
#     for a, b in f.items()
# }

# print(g)

# recherche_motif = rmt = lambda racine, motif, dossier1st='d': [
#     str(item)
#     for dossier, sous_dossiers, fichiers in os.walk(Path(racine))
#     for item in (
#         [*(Path(dossier)/d for d in sous_dossiers), *(Path(dossier)/f for f in fichiers)]
#         if dossier1st == 'd'
#         else [*(Path(dossier)/f for f in fichiers), *(Path(dossier)/d for d in sous_dossiers)]
#     )
#     if re.search(motif, item.name, re.I)
# ]
# # Exemple d'utilisation :
# racine = Path(__file__).resolve().parent.parent

# fl = """ 
# base_path : "bbb"
# lauch_sh : r"*.sh"
# launch_py : 
# latex_file : writing.tex
# pdf_file : writing.pdf
# path_vault:   example_vault  
# path_writing:   ‚úçWriting  
# path_templates:   üë®‚ÄçüíªAutomations  
# path_table_block_template:   table_block.md  
# path_equation_block_template:   equation_block_single.md  
# path_equation_blocks:   equation blocks  
# path_table_blocks:   table blocks  
# path_list_note_paths:   DO_NOT_DELETE__note_paths.txt  
# path_BIBTEX:   BIBTEX  
# """ # les valeurs prdefaut 

# motifs =f = {cle: (yaml.safe_load(open("fl.md", encoding="utf-8")) 
#             if Path("fl.md").is_file() else {}).get(cle) 
#                 or val for cle, val in yaml.safe_load(fl).items()}


# cle_pattern_paths = clpp = {
#     cle: f"{cle} {(f'\"{chemins[0]}\"' 
#                        if (chemins := rmt(racine, motif)) 
#                        else '\"affich non trouv√©\"')}"
#     for cle, motif in motifs.items()
# }

